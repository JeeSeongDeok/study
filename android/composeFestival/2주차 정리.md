## 3. Modifiers
Modifiers를 이용하면 컴포저블을 꾸밀 수 있다. 동작, 모양을 변경하고, 접근성 레입르과 같은 정보를 추가, 사용자 입력을 처리하거나 클릭 가능, 스크롤 가능, 드래그 가능 또는 확대/축소 가능과 같은 고급 상호 작용도 추가가 가능하다.<br>

수정자는 일반 코틀린 객체. 변수에 할당하고 재사용할 수 있다. <br> 
대부분의 컴포저블은 선택적 modifier 매개변수를 받아 유연하게 만들어 호출자가 수정할 수 있다.<br>
자신만의 컴포저블을 생성하는 경우 수정자를 매개변수로 사용하는 것을 고려하고 기본적으로 숮어자로 설정하고 이를 함수의 루트 컴포저블에 적용한다.<br>

### Modifier의 순서 중요성
``` kotlin
@Composable
fun PhotographerCard(modifier: Modifier = Modifier) {
    Row(modifier
        .padding(16.dp)
        .clickable(onClick = { /* Ignoring onClick */ })
    ) {
        ...
    }
}
```
위에 코드처럼 .padding 후 .clickable을 한 경우 클릭 가능한 수정자 전에 패딩이 적용이 되었기 때문에 아래의 사진처럼 작동함.<br>
<img src = "https://developer.android.com/codelabs/jetpack-compose-layouts/img/c15a1050b051617f.gif?authuser=4"><br>
따라서, 패딩과 clickable의 위치를 변경 시 아래처럼 됨<br>
<img src = "https://developer.android.com/codelabs/jetpack-compose-layouts/img/a1ea4c8e16d61ffa.gif?authuser=4"><br>

이런 방식을 이용하면 외부 간격을 추가한 뒤 클릭 시 둥근 모양을 보여주고 싶다면 아래와 같은 코드를 사용하면 된다.
``` kotlin
@Composable
fun PhotographerCard(modifier: Modifier = Modifier) {
    Row(modifier
        .padding(8.dp)
        .clip(RoundedCornerShape(4.dp))
        .background(MaterialTheme.colors.surface)
        .clickable(onClick = { /* Ignoring onClick */ })
        .padding(16.dp)
    ) {
        ...
    }
}
```

## 4.Slot API
사용자 정의 레이어를 가져오기 위해 Compose가 도입한 패턴이다.<br>

## 5. Material Components
### Scaffold
Material Design 레이아웃 구조로 UI를 구현할 수 있다. TopAppBar, BottomAppBar, FloatingActionBar 및 Drawer와 같은 것을 구성할 수 있다.

### TopAppBar
슬롯 API 패턴에 따라 TopAppBar의 제목 슬롯에 화면 제목이 있는 텍스트가 포함되어야함 <br>
TopAppBar는 미리 구성된 아이콘을 쓸 수 있다.<br>

### LazyList
<img src = "https://developer.android.com/codelabs/jetpack-compose-layouts/img/9c6a666c57a84211.gif?authuser=4"><br>
위 이미지와 같이 스크롤을 하는 동안 목록을 렌더링하기 때문에 이미지가 늦게 뜨거나 일정하지 않게 뜨는 경우가 있다. <br>
이 경우를 방지하기 위해 RememberCoroutineScope 함수를 사용해서 CoroutineScope를 생성해서 제어한다. <br>

```kotlin
val listSize = 100
// 스크롤 위치를 저장하는 상태객체
val scrollState = rememberLazyListState()
// 애니메이션 스크롤이 실행될 코루틴 범위를 저장
val coroutineScope = rememberCoroutineScope()
```
<img src = "https://developer.android.com/codelabs/jetpack-compose-layouts/img/9bc52801a90401f3.gif?authuser=4"><br> 

### LazyList
<img src = "https://developer.android.com/codelabs/jetpack-compose-layouts/img/9c6a666c57a84211.gif?authuser=4"><br>
위 이미지와 같이 스크롤을 하는 동안 목록을 렌더링하기 때문에 이미지가 늦게 뜨거나 일정하지 않게 뜨는 경우가 있다. <br>
이 경우를 방지하기 위해 RememberCoroutineScope 함수를 사용해서 CoroutineScope를 생성해서 제어한다. <br>

```kotlin
val listSize = 100
// 스크롤 위치를 저장하는 상태객체
val scrollState = rememberLazyListState()
// 애니메이션 스크롤이 실행될 코루틴 범위를 저장
val coroutineScope = rememberCoroutineScope()
```

## 7. Create your custom layout
Column, Row, Box를 사용하지 않고 Custom으로 레이아웃을 만들 수 있다.<br>
Custom layout을 만들기 위해서는 Compose의 레이아웃 원칙을 아는 것이 중요하다. <br>

### Compose의 레이아웃 원칙
일부 구성 가능한 함수는 호출될 때 화면에 렌더링될 UI 트리에 추가되는 UI Element를 보낸다. 각 요소에는 하나의 부모와 잠재적으로 많은 자식이 있다. 그리고 부모 내 위치 및 크기가 있다.<br>
element는 충족되어야 하는 Constraints로 스스로 측정해야함. <br> 
제약 조건은 요소의 최소 및 최대 너비와 높이를 제한해야한다. <br>
ComposeUI는 다중 패스 측정을 허용하지 않는다. <br>
레이아웃 요소가 다른 측정 구성을 시도하기 위해 자식을 두번 이상 측정하지 않는다. <br>

레이아웃 수정자를 사용할 때 두개의 람다 매개변수를 얻는다.
```kotlin
fun Modifier.customLayoutModifier(...) = Modifier.layout { measurable, constraints ->
  ...
})
```
measurable: child의 측정 및 배치<br>
constraints:  child의 너비와 높이에 대한 최소 및 최대<br>

화면에 텍스트를 제어하기위해 BaseLine의 거리를 제어할려고 한다.

```kotlin
fun Modifier.firstBaselineToTop(
  firstBaselineToTop: Dp
) = this.then(
    layout { measurable, constraints ->
        ...
    }
)
```
가장 먼저 할 일은 컴포저블을 측정한다. <br>
Compose의 레이아웃은 앞의 원칙에서 언급했듯이 한 번만 측정할 수 있다.<br>
measurable.measure(constraints)를 호출하여 컴포저블을 측정합니다.<br>
measure(constraints)를 호출할 때 제약 조건 람다 매개변수에서 사용 가능한 컴포저블의 주어진 제약 조건을 전달하거나 직접 생성할 수 있습니다.<br>
 Measurable에 대한 measure() 호출의 결과는 나중에 할 것처럼 placeRelative(x, y)를 호출하여 위치를 지정할 수 있는 Placeable입니다.<br>



